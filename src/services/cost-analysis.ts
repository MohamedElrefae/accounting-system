// src/services/cost-analysis.ts
// Supabase client-only service for Cost Analysis line items

import { supabase } from '../utils/supabase'

export type TransactionLineItem = {
  id?: string
  transaction_id: string
  line_number?: number
  item_code?: string | null
  item_name?: string | null
  item_name_ar?: string | null
  description?: string | null
  description_ar?: string | null
  quantity: number
  percentage: number
  unit_price: number
  unit_of_measure?: string
  analysis_work_item_id?: string | null
  expenses_category_id?: string | null
  total_amount?: number // generated by DB
  org_id?: string
  created_at?: string
  updated_at?: string
}

export function computeLineTotal(qty: number, pct: number, price: number): number {
  const q = Number.isFinite(qty) ? qty : 0
  const p = Number.isFinite(pct) ? pct : 0
  const up = Number.isFinite(price) ? price : 0
  // Mirror DB: quantity * (percentage/100.0) * unit_price
  return +(q * (p / 100) * up).toFixed(4)
}

export function validateItems(items: TransactionLineItem[]): { ok: boolean; errors: string[] } {
  const errors: string[] = []
  items.forEach((it, idx) => {
    if (it.quantity < 0) errors.push(`Row ${idx + 1}: quantity cannot be negative`)
    if (it.unit_price < 0) errors.push(`Row ${idx + 1}: unit price cannot be negative`)
    if (it.percentage < 0 || it.percentage > 999.99) errors.push(`Row ${idx + 1}: percentage out of range 0-999.99`)
    const computed = computeLineTotal(it.quantity, it.percentage, it.unit_price)
    if (it.total_amount != null && +(+it.total_amount).toFixed(4) !== computed) {
      // Not fatal; DB is source of truth, but warn
    }
  })
  return { ok: errors.length === 0, errors }
}

export async function listLineItems(transactionId: string) {
  const { data, error } = await supabase
    .from('transaction_line_items')
    .select(`
      id, transaction_id, line_number, item_code, item_name, item_name_ar,
      description, description_ar, quantity, percentage, unit_price,
      unit_of_measure, analysis_work_item_id, expenses_category_id,
      total_amount, org_id, created_at, updated_at
    `)
    .eq('transaction_id', transactionId)
    .order('line_number', { ascending: true })
  if (error) throw error
  return (data ?? []) as TransactionLineItem[]
}

export async function upsertLineItems(transactionId: string, items: TransactionLineItem[]) {
  const { ok, errors } = validateItems(items)
  if (!ok) {
    const err = new Error('Validation failed: ' + errors.join('; '))
    ;(err as any).validation = errors
    throw err
  }

  const payload = items.map((it, idx) => ({
    ...it,
    transaction_id: transactionId,
    line_number: it.line_number ?? idx + 1,
  }))

  const { data, error } = await supabase
    .from('transaction_line_items')
    .upsert(payload, {
      onConflict: 'id',
      ignoreDuplicates: false,
    })
    .select('*')

  if (error) throw error
  return data as TransactionLineItem[]
}

/**
 * Replace all line items for a transaction with the provided set.
 * Deletes rows not present in items (by id), then upserts the provided set.
 */
export async function bulkReplaceLineItems(transactionId: string, items: TransactionLineItem[]) {
  const existing = await listLineItems(transactionId)
  const existingIds = new Set(existing.map(r => r.id!).filter(Boolean))
  const incomingIds = new Set(items.map(r => r.id!).filter(Boolean))

  const toDelete = [...existingIds].filter(id => !incomingIds.has(id))
  if (toDelete.length > 0) {
    const { error: delErr } = await supabase
      .from('transaction_line_items')
      .delete()
      .in('id', toDelete)
      .eq('transaction_id', transactionId)
    if (delErr) throw delErr
  }

  return await upsertLineItems(transactionId, items)
}

export async function deleteLineItem(id: string) {
  const { error } = await supabase
    .from('transaction_line_items')
    .delete()
    .eq('id', id)
  if (error) throw error
  return true
}
