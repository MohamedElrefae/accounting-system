// src/services/cost-analysis.ts
// Supabase client-only service for Cost Analysis line items

import { supabase } from '../utils/supabase'

export type TransactionLineItem = {
  id?: string
  transaction_id: string // UI context only
  transaction_line_id?: string | null
  line_number?: number
  // Display fields (now persisted on table for performance)
  item_code?: string | null
  item_name?: string | null
  item_name_ar?: string | null
  quantity: number
  percentage: number
  unit_price: number
  unit_of_measure?: string | null
  analysis_work_item_id?: string | null
  sub_tree_id?: string | null
  line_item_catalog_id?: string | null
  work_item_id?: string | null
  total_amount?: number // generated by DB
  org_id?: string | null
  created_at?: string
  updated_at?: string
}

export function computeLineTotal(qty: number, pct: number, price: number): number {
  const q = Number.isFinite(qty) ? qty : 0
  const p = Number.isFinite(pct) ? pct : 0
  const up = Number.isFinite(price) ? price : 0
  // Mirror DB calculation exactly: quantity * (percentage / 100.0) * unit_price
  return q * (p / 100.0) * up
}

export function validateItems(items: TransactionLineItem[]): { ok: boolean; errors: string[] } {
  const errors: string[] = []
  items.forEach((it, idx) => {
    if (it.quantity < 0) errors.push(`Row ${idx + 1}: quantity cannot be negative`)
    if (it.unit_price < 0) errors.push(`Row ${idx + 1}: unit price cannot be negative`)
    if (it.percentage < 0 || it.percentage > 999.99) errors.push(`Row ${idx + 1}: percentage out of range 0-999.99`)
    // total_amount is calculated by database, so we don't validate it here
    // const computed = computeLineTotal(it.quantity, it.percentage, it.unit_price)
  })
  return { ok: errors.length === 0, errors }
}

export async function listLineItems(transactionId: string, transactionLineId?: string) {
  // If we have a transactionLineId, query the base table directly and ignore transactionId.
  if (transactionLineId) {
    const { data, error } = await supabase
      .from('transaction_line_items')
      .select(`
        id, transaction_line_id, line_number,
        quantity, percentage, unit_price,
        unit_of_measure, analysis_work_item_id, sub_tree_id,
        line_item_catalog_id, work_item_id,
        item_code, item_name, item_name_ar,
        total_amount, org_id, created_at, updated_at
      `)
      .eq('transaction_line_id', transactionLineId)
      .order('line_number', { ascending: true })
    if (error) throw error
    
    // Batch enrichment: collect missing catalog IDs and fetch once
    const missingCatalogIds = new Set<string>()
    ;(data ?? []).forEach((r: any) => {
      if (r.line_item_catalog_id && !r.item_code) {
        missingCatalogIds.add(r.line_item_catalog_id)
      }
    })
    
    let catalogMap = new Map<string, any>()
    if (missingCatalogIds.size > 0) {
      try {
        const { data: catalogItems } = await supabase
          .from('line_items')
          .select('id, code, name, name_ar')
          .in('id', Array.from(missingCatalogIds))
        
        if (catalogItems) {
          catalogItems.forEach((item: any) => {
            catalogMap.set(item.id, item)
          })
        }
      } catch (e) {
        console.warn('Failed to batch load catalog items:', e)
      }
    }
    
    // Map items with enriched or stored catalog data
    const enrichedItems = (data ?? []).map((r: any) => {
      let catalogDetails: any = {}
      // Use stored metadata first, then fallback to batch-fetched data
      if (r.item_code) {
        catalogDetails = {
          item_code: r.item_code,
          item_name: r.item_name,
          item_name_ar: r.item_name_ar
        }
      } else if (r.line_item_catalog_id && catalogMap.has(r.line_item_catalog_id)) {
        const catalogItem = catalogMap.get(r.line_item_catalog_id)
        catalogDetails = {
          item_code: catalogItem.code,
          item_name: catalogItem.name,
          item_name_ar: catalogItem.name_ar
        }
      }
      
      return {
        id: r.id,
        transaction_id: transactionId,
        transaction_line_id: r.transaction_line_id,
        line_number: r.line_number,
        line_item_catalog_id: r.line_item_catalog_id,
        work_item_id: r.work_item_id,
        ...catalogDetails,
        quantity: r.quantity,
        percentage: r.percentage,
        unit_price: r.unit_price,
        unit_of_measure: r.unit_of_measure,
        analysis_work_item_id: r.analysis_work_item_id,
        sub_tree_id: r.sub_tree_id,
        total_amount: r.total_amount,
        org_id: r.org_id,
        created_at: r.created_at,
        updated_at: r.updated_at,
      }
    })
    
    return enrichedItems as TransactionLineItem[]
  }

  // If only transactionId is provided but the schema no longer links lines to transactions,
  // return empty to avoid 404s until a replacement relation is provided server-side.
  try {
    const { data, error } = await supabase
      .from('v_transaction_line_items_with_context')
      .select(`
        id, transaction_line_id, line_number,
        quantity, percentage, unit_price,
        unit_of_measure, analysis_work_item_id, sub_tree_id,
        line_item_catalog_id, work_item_id,
        item_code, item_name, item_name_ar,
        total_amount, org_id, created_at, updated_at
      `)
      .order('transaction_line_id', { ascending: true })
      .order('line_number', { ascending: true })
    if (error) throw error
    
    // Batch enrichment for missing catalog data
    const missingCatalogIds = new Set<string>()
    ;(data ?? []).forEach((r: any) => {
      if (r.line_item_catalog_id && !r.item_code) {
        missingCatalogIds.add(r.line_item_catalog_id)
      }
    })
    
    let catalogMap = new Map<string, any>()
    if (missingCatalogIds.size > 0) {
      try {
        const { data: catalogItems } = await supabase
          .from('line_items')
          .select('id, code, name, name_ar')
          .in('id', Array.from(missingCatalogIds))
        
        if (catalogItems) {
          catalogItems.forEach((item: any) => {
            catalogMap.set(item.id, item)
          })
        }
      } catch (e) {
        console.warn('Failed to batch load catalog items:', e)
      }
    }
    
    // Map items with enriched data
    const enrichedItems = (data ?? []).map((r: any) => {
      let catalogDetails: any = {}
      if (r.item_code) {
        catalogDetails = {
          item_code: r.item_code,
          item_name: r.item_name,
          item_name_ar: r.item_name_ar
        }
      } else if (r.line_item_catalog_id && catalogMap.has(r.line_item_catalog_id)) {
        const catalogItem = catalogMap.get(r.line_item_catalog_id)
        catalogDetails = {
          item_code: catalogItem.code,
          item_name: catalogItem.name,
          item_name_ar: catalogItem.name_ar
        }
      }
      
      return {
        id: r.id,
        transaction_id: transactionId,
        transaction_line_id: r.transaction_line_id,
        line_number: r.line_number,
        line_item_catalog_id: r.line_item_catalog_id,
        work_item_id: r.work_item_id,
        ...catalogDetails,
        quantity: r.quantity,
        percentage: r.percentage,
        unit_price: r.unit_price,
        unit_of_measure: r.unit_of_measure,
        analysis_work_item_id: r.analysis_work_item_id,
        sub_tree_id: r.sub_tree_id,
        total_amount: r.total_amount,
        org_id: r.org_id,
        created_at: r.created_at,
        updated_at: r.updated_at,
      }
    })
    
    return enrichedItems as TransactionLineItem[]
  } catch {
    return []
  }
}

export async function upsertLineItems(transactionId: string, items: TransactionLineItem[], opts?: { transactionLineId?: string }) {
  const { ok, errors } = validateItems(items)
  if (!ok) {
    const err = new Error('Validation failed: ' + errors.join('; '))
    ;(err as any).validation = errors
    throw err
  }

  // Resolve org_id and a default transaction_line_id (first line) for this transaction
  let txOrgId: string | null = null
  let defaultTxLineId: string | null = null
  try {
    const { data: tx } = await supabase
      .from('transactions')
      .select('org_id')
      .eq('id', transactionId)
      .single()
    txOrgId = tx?.org_id || null
  } catch {
    txOrgId = null
  }
  try {
    if (opts?.transactionLineId) {
      defaultTxLineId = opts.transactionLineId
    } else {
      const { data: tl } = await supabase
        .from('transaction_lines')
        .select('id')
        .eq('transaction_id', transactionId)
        .order('line_no', { ascending: true })
        .limit(1)
        .maybeSingle()
      defaultTxLineId = tl?.id || null
    }
  } catch {
    defaultTxLineId = null
  }

  const nullable = (v: any) => (v === '' || v === undefined ? null : v)

  const newItems = items.filter(item => !item.id)
  const existingItems = items.filter(item => item.id)

  const results: TransactionLineItem[] = []

  if (newItems.length > 0) {
    const newPayload = newItems.map((it, idx) => ({
      transaction_line_id: it.transaction_line_id ?? defaultTxLineId,
      line_number: it.line_number ?? (existingItems.length + idx + 1),
      quantity: it.quantity,
      percentage: it.percentage,
      unit_price: it.unit_price,
      unit_of_measure: nullable(it.unit_of_measure) ?? null,
      work_item_id: nullable(it.work_item_id),
      analysis_work_item_id: nullable(it.analysis_work_item_id),
      sub_tree_id: nullable(it.sub_tree_id),
      line_item_catalog_id: nullable(it.line_item_catalog_id),
      org_id: nullable(it.org_id) ?? txOrgId,
    }))

    const { data: newData, error: newError } = await supabase
      .from('transaction_line_items')
      .insert(newPayload)
      .select('*')

    if (newError) throw newError
    if (newData) results.push(...(newData as any[]).map(r => ({ ...r, transaction_id: transactionId })))
  }

  if (existingItems.length > 0) {
    const updatePayload = existingItems.map((it, idx) => ({
      id: it.id!,
      transaction_line_id: it.transaction_line_id ?? defaultTxLineId,
      line_number: it.line_number ?? idx + 1,
      quantity: it.quantity,
      percentage: it.percentage,
      unit_price: it.unit_price,
      unit_of_measure: nullable(it.unit_of_measure) ?? null,
      work_item_id: nullable(it.work_item_id),
      analysis_work_item_id: nullable(it.analysis_work_item_id),
      sub_tree_id: nullable(it.sub_tree_id),
      line_item_catalog_id: nullable(it.line_item_catalog_id),
      org_id: nullable(it.org_id) ?? txOrgId,
      updated_at: new Date().toISOString(),
    }))

    const { data: updateData, error: updateError } = await supabase
      .from('transaction_line_items')
      .upsert(updatePayload, { onConflict: 'id', ignoreDuplicates: false })
      .select('*')

    if (updateError) throw updateError
    if (updateData) results.push(...(updateData as any[]).map(r => ({ ...r, transaction_id: transactionId })))
  }

  return results.sort((a, b) => (a.line_number || 0) - (b.line_number || 0))
}

/**
 * Replace all line items for a transaction with the provided set.
 * Deletes rows not present in items (by id), then upserts the provided set.
 * NOTE: Only deletes items that:
 *   1. Exist in the database
 *   2. Are NOT in the incoming items list (by id comparison)
 *   3. Ignores new items without IDs (they have nothing to delete)
 */
export async function bulkReplaceLineItems(transactionId: string, items: TransactionLineItem[], opts?: { transactionLineId?: string }) {
  const existing = await listLineItems(transactionId)
  
  // Only consider items with IDs for deletion logic
  const existingIds = new Set(existing.map(r => r.id!).filter(Boolean))
  const incomingIds = new Set(items.map(r => r.id!).filter(Boolean))

  // Delete only items that exist in DB but are NOT in the incoming list
  const toDelete = [...existingIds].filter(id => !incomingIds.has(id))
  if (toDelete.length > 0) {
    const { error: delErr } = await supabase
      .from('transaction_line_items')
      .delete()
      .in('id', toDelete)
    if (delErr) throw delErr
  }

  // Upsert handles both new items (insert) and existing items (update)
  return await upsertLineItems(transactionId, items, opts)
}

export async function deleteLineItem(id: string) {
  const { error } = await supabase
    .from('transaction_line_items')
    .delete()
    .eq('id', id)
  if (error) throw error
  return true
}
