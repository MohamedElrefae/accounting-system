import { supabase, Account, Transaction, JournalEntry, JournalEntryLine } from './supabase'

// Account Services
export const accountService = {
  // Get all accounts
  async getAll(): Promise<Account[]> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .order('name')
    
    if (error) throw error
    return data || []
  },

  // Get account by ID
  async getById(id: string): Promise<Account | null> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('id', id)
      .single()
    
    if (error) throw error
    return data
  },

  // Get accounts by type
  async getByType(type: Account['type']): Promise<Account[]> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('type', type)
      .order('name')
    
    if (error) throw error
    return data || []
  },

  // Create new account
  async create(account: Omit<Account, 'id' | 'created_at' | 'updated_at'>): Promise<Account> {
    const { data, error } = await supabase
      .from('accounts')
      .insert(account)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Update account
  async update(id: string, updates: Partial<Omit<Account, 'id' | 'created_at'>>): Promise<Account> {
    const { data, error } = await supabase
      .from('accounts')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Delete account
  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('accounts')
      .delete()
      .eq('id', id)
    
    if (error) throw error
  },

  // Update account balance
  async updateBalance(id: string, newBalance: number): Promise<Account> {
    return this.update(id, { balance: newBalance })
  }
}

// Transaction Services
export const transactionService = {
  // Get all transactions
  async getAll(): Promise<Transaction[]> {
    const { data, error } = await supabase
      .from('transactions')
      .select(`
        *,
        account:accounts(name, type)
      `)
      .order('date', { ascending: false })
    
    if (error) throw error
    return data || []
  },

  // Get transactions by account
  async getByAccount(accountId: string): Promise<Transaction[]> {
    const { data, error } = await supabase
      .from('transactions')
      .select(`
        *,
        account:accounts(name, type)
      `)
      .eq('account_id', accountId)
      .order('date', { ascending: false })
    
    if (error) throw error
    return data || []
  },

  // Get transactions by date range
  async getByDateRange(startDate: string, endDate: string): Promise<Transaction[]> {
    const { data, error } = await supabase
      .from('transactions')
      .select(`
        *,
        account:accounts(name, type)
      `)
      .gte('date', startDate)
      .lte('date', endDate)
      .order('date', { ascending: false })
    
    if (error) throw error
    return data || []
  },

  // Create new transaction
  async create(transaction: Omit<Transaction, 'id' | 'created_at' | 'updated_at'>): Promise<Transaction> {
    const { data, error } = await supabase
      .from('transactions')
      .insert(transaction)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Update transaction
  async update(id: string, updates: Partial<Omit<Transaction, 'id' | 'created_at'>>): Promise<Transaction> {
    const { data, error } = await supabase
      .from('transactions')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Delete transaction
  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('transactions')
      .delete()
      .eq('id', id)
    
    if (error) throw error
  }
}

// Journal Entry Services
export const journalEntryService = {
  // Get all journal entries with their lines
  async getAll(): Promise<(JournalEntry & { lines: (JournalEntryLine & { account: Account })[] })[]> {
    const { data, error } = await supabase
      .from('journal_entries')
      .select(`
        *,
        lines:journal_entry_lines(
          *,
          account:accounts(*)
        )
      `)
      .order('date', { ascending: false })
    
    if (error) throw error
    return data || []
  },

  // Get journal entry by ID with lines
  async getById(id: string): Promise<(JournalEntry & { lines: (JournalEntryLine & { account: Account })[] }) | null> {
    const { data, error } = await supabase
      .from('journal_entries')
      .select(`
        *,
        lines:journal_entry_lines(
          *,
          account:accounts(*)
        )
      `)
      .eq('id', id)
      .single()
    
    if (error) throw error
    return data
  },

  // Create new journal entry with lines
  async create(
    entry: Omit<JournalEntry, 'id' | 'created_at' | 'updated_at'>,
    lines: Omit<JournalEntryLine, 'id' | 'journal_entry_id' | 'created_at' | 'updated_at'>[]
  ): Promise<JournalEntry> {
    // Validate that debits equal credits
    const totalDebits = lines.reduce((sum, line) => sum + line.debit_amount, 0)
    const totalCredits = lines.reduce((sum, line) => sum + line.credit_amount, 0)
    
    if (Math.abs(totalDebits - totalCredits) > 0.01) {
      throw new Error('Debits must equal credits in a journal entry')
    }

    // Create journal entry
    const { data: journalEntry, error: entryError } = await supabase
      .from('journal_entries')
      .insert(entry)
      .select()
      .single()
    
    if (entryError) throw entryError

    // Create journal entry lines
    const linesWithEntryId = lines.map(line => ({
      ...line,
      journal_entry_id: journalEntry.id
    }))

    const { error: linesError } = await supabase
      .from('journal_entry_lines')
      .insert(linesWithEntryId)
    
    if (linesError) {
      // Cleanup: delete the journal entry if lines creation failed
      await supabase.from('journal_entries').delete().eq('id', journalEntry.id)
      throw linesError
    }

    return journalEntry
  },

  // Delete journal entry (will cascade to lines)
  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('journal_entries')
      .delete()
      .eq('id', id)
    
    if (error) throw error
  }
}

// Reporting Services
export const reportingService = {
  // Get trial balance
  async getTrialBalance(): Promise<{ account: Account; debit: number; credit: number }[]> {
    const { data: accounts, error: accountsError } = await supabase
      .from('accounts')
      .select('*')
      .order('name')
    
    if (accountsError) throw accountsError

    const { data: journalLines, error: linesError } = await supabase
      .from('journal_entry_lines')
      .select(`
        account_id,
        debit_amount,
        credit_amount,
        account:accounts(*)
      `)
    
    if (linesError) throw linesError

    // Calculate balances for each account
    const trialBalance = accounts.map(account => {
      const accountLines = journalLines.filter(line => line.account_id === account.id)
      const totalDebits = accountLines.reduce((sum, line) => sum + line.debit_amount, 0)
      const totalCredits = accountLines.reduce((sum, line) => sum + line.credit_amount, 0)
      
      let debit = 0
      let credit = 0
      
      // Determine if account has a debit or credit balance
      const netBalance = totalDebits - totalCredits
      if (netBalance > 0) {
        debit = netBalance
      } else if (netBalance < 0) {
        credit = Math.abs(netBalance)
      }
      
      return {
        account,
        debit,
        credit
      }
    })
    
    return trialBalance.filter(item => item.debit > 0 || item.credit > 0)
  },

  // Get income statement data
  async getIncomeStatement(startDate: string, endDate: string) {
    const { data: journalLines, error } = await supabase
      .from('journal_entry_lines')
      .select(`
        debit_amount,
        credit_amount,
        account:accounts(*),
        journal_entry:journal_entries(date)
      `)
      .gte('journal_entry.date', startDate)
      .lte('journal_entry.date', endDate)
    
    if (error) throw error

    const revenues = journalLines
      .filter(line => line.account.type === 'revenue')
      .reduce((sum, line) => sum + line.credit_amount - line.debit_amount, 0)
    
    const expenses = journalLines
      .filter(line => line.account.type === 'expense')
      .reduce((sum, line) => sum + line.debit_amount - line.credit_amount, 0)
    
    return {
      revenues,
      expenses,
      netIncome: revenues - expenses
    }
  }
}

// Utility function to test database connection
export const testConnection = async (): Promise<boolean> => {
  try {
    const { data, error } = await supabase
      .from('accounts')
      .select('count', { count: 'exact' })
      .limit(1)
    
    return !error
  } catch {
    return false
  }
}
