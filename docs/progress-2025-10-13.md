# Multiline Accounting Refactor — Progress Report (as of 2025-10-13)

This document summarizes completed work and remaining actions for migrating to a unified multiline ledger model, preparing analysis-friendly data products, and deprecating legacy single-line dependencies.

## Status Summary

Overall status: on track. Core views are line-based; header aggregates are maintained by triggers; reporting and export datasets are in place. Some legacy header columns remain pending due to final view/trigger rewrites.

## Completed Work

1) Header/lines model and aggregation
- Line-driven aggregation trigger installed and active:
  - fn_tx_update_totals_and_counts() updates: total_debits, total_credits, line_items_count, line_items_total, has_line_items on transactions from transaction_lines writes
  - Triggers on transaction_lines and transactions attached (after insert/update/delete as appropriate)
- Header-only fields removed or prepped for removal:
  - amount: fully removed after converting all dependent views to use line totals
  - classification, cost center, project: dependent views rewritten to line-based where applicable (see Views section)

2) Views migrated to line-based (or updated)
- Posting/reporting core:
  - balance_sheet_view_v2, income_statement_view_v2, financial_summary_view_v2, trial_balance_view_v2 — all line-based
  - Canonical wrappers (balance_sheet_view, income_statement_view, financial_summary_view, trial_balance_view) point to v2
- Operational analytics and rollups:
  - v_tx_lines — uses tl.project_id (removed dependency on transactions.project_id)
  - v_tx_lines_signed, v_account_balances, v_category_totals — work with the updated v_tx_lines
  - v_cost_center_costs_monthly — line-based (uses tl.cost_center_id and tl.classification_id via transaction_classification)
  - v_cost_centers — line-based transactions_count/last_used_at (joins tl + t on org)
- Validation and AP:
  - transaction_validation_report_v2 — amount derived from line totals (type preserved)
  - v_ap_invoice_postings_v2 — amount derived from line totals (type preserved)
  - Canonical wrappers (transaction_validation_report, v_ap_invoice_postings) point to v2
- Cost analysis set:
  - v_cost_analysis_summary — transaction_amount derived from line totals (numeric(18,4) preserved)
  - v_cost_analysis_summary_mv — rebuilt to depend on updated base view (with unique index for concurrent refresh if needed)
- Sub-tree and categories:
  - sub_tree_full_v2 — line-based has_transactions via tl.sub_tree_id; canonical sub_tree_full wrapper updated
  - v_expenses_categories_rollups_v2 — line-based; canonical view and MV depend on v2

3) GL analysis datasets (new)
- v_gl_lines_with_counterparty — line-grain fact with counterparty account arrays; includes header and dimensional context; posted/unposted indicated by is_posted
- v_gl_pairwise_entries — pairwise normalized allocations using cumulative-interval overlap; numeric(38,6); posted/unposted covered
- Materialized views (performance):
  - mv_gl_lines_fact with unique and helpful indexes (line_id, transaction_id, org_id, account_id, posted/date)
  - mv_gl_pairwise_entries with unique composite and helpful indexes (transaction_id, posted/date, debit/credit accounts)
  - Optional pg_cron schedules and refresh function prepared (refresh_gl_mviews_concurrent / refresh_reporting_matviews_concurrent)

4) Transaction-level export datasets
- v_gl_transactions_fact — one row per transaction with arrays of debit/credit accounts, totals, dimensional arrays, is_balanced
- v_gl_transactions_export_flat — CSV-friendly flattened export that explodes arrays to repeated rows (type-preserving)
- Materialized variants prepared (mv_gl_transactions_fact, mv_gl_transactions_export_flat) with indexes and optional pg_cron refresh wrapper refresh_gl_exports_concurrent()

## Columns removed from transactions
- amount — dropped after converting all dependent views
- Other header fields removed (or prepped with view rewrites):
  - classification_id — removed after v_cost_center_costs_monthly and v*_v2 updates
  - cost_center_id — removed after v_cost_centers line-based rewrite
  - project_id — removed after v_tx_lines rewrite and v*_v2 updates

Note: In each case, we used column-level dependency discovery to identify dependents, then provided type-preserving CREATE OR REPLACE VIEW statements before dropping the column.

## Pending Items (recommended next)

Priority 1 — Remove source fields from header
- transactions.source_module and transactions.source_reference_id
  - Trigger function tg_upsert_inventory_posting_after_tx() is now line-driven (checks tl.source_module/source_document_id). Ensure the trigger itself has been recreated without header column dependencies (AFTER INSERT OR UPDATE OF posted_at OR all updates)
  - legacy_compat.v_journals_single_line and posted-filter view
    - Replace references to header source fields with line-level fields (tl.source_module, tl.source_document_id) with exact type casts; OR set them to NULL::text / NULL::uuid to decouple entirely
  - After both above, drop the header columns safely

Priority 2 — UI / API refactor finishing
- Ensure forms submit header + lines[] only; remove any traces of legacy single-line posting
- Client-side rules mirror DB: one side positive per line, >= two lines per transaction, totals balanced; leaf+active+allowed account picker
- Fix any remaining page errors referencing removed header fields

Priority 3 — Optional posted-only helper views
- v_gl_lines_with_counterparty_posted and v_gl_pairwise_entries_posted wrappers
- v_gl_transactions_export_flat_posted wrapper for export convenience

Priority 4 — Materialization & scheduling (if needed)
- Add CONCURRENTLY refresh schedules via pg_cron
- Consider partitioned export tables for very large datasets (by month) and partial refresh helpers (by org/date)

## Operational Checklists (stop-and-verify)

1) Column-level dependency discovery (accurate)
```sql path=null start=null
SELECT
  cls.relname AS dependent_view,
  att.attname AS referenced_column
FROM pg_depend dep
JOIN pg_rewrite rw    ON rw.oid = dep.objid
JOIN pg_class   cls   ON cls.oid = rw.ev_class
JOIN pg_attribute att ON att.attrelid = dep.refobjid AND att.attnum = dep.refobjsubid
WHERE dep.refobjid = 'public.transactions'::regclass
  AND att.attname = '{{COLUMN_NAME}}'
ORDER BY dependent_view;
```

2) Drop header columns (table only) after view fixes
```sql path=null start=null
ALTER TABLE public.transactions
  DROP COLUMN IF EXISTS {{COLUMN_NAME}};
```

3) Totals sanity check (lines vs header aggregates)
```sql path=null start=null
SELECT t.id
FROM public.transactions t
JOIN LATERAL (
  SELECT
    COALESCE(SUM(debit_amount),0)::numeric   AS debits,
    COALESCE(SUM(credit_amount),0)::numeric  AS credits,
    COUNT(*)::integer                         AS cnt,
    COALESCE(SUM(debit_amount+credit_amount),0)::numeric AS total
  FROM public.transaction_lines tl
  WHERE tl.transaction_id = t.id
) sub ON true
WHERE t.total_debits  <> sub.debits
   OR t.total_credits <> sub.credits
   OR t.line_items_count <> sub.cnt
   OR t.line_items_total <> sub.total
LIMIT 10;
```

4) Materialized views refresh
```sql path=null start=null
-- Concurrent refresh if unique indexes present
SELECT public.refresh_reporting_matviews_concurrent();
SELECT public.refresh_gl_exports_concurrent();

-- Ad hoc
REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_gl_lines_fact;
REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_gl_pairwise_entries;
REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_gl_transactions_fact;
REFRESH MATERIALIZED VIEW CONCURRENTLY public.mv_gl_transactions_export_flat;
```

## Decisions/Assumptions
- transaction_amount in v_cost_analysis_summary is numeric(18,4) and must be preserved; all replacements cast accordingly
- posted/unposted always indicated by is_posted boolean from header; views include both unless otherwise filtered
- Normalized pairwise view does not mutate original lines; it allocates via cumulative-interval overlap, summing to exact ledger totals

## Risks & Mitigations
- Hidden dependencies in legacy views/functions: mitigate with column-level dependency discovery and type-preserving CREATE OR REPLACE VIEW
- Type mismatch on CREATE OR REPLACE VIEW: always match existing column types exactly (numeric vs numeric(18,4), varchar(255), uuid, boolean) and cast accordingly
- Export row explosion when flattening arrays: provide line-based CSV exports or limit which arrays are unnested for downstream CSV use cases

## Request for Review (Client AI Agent)
Please review and confirm:
- Header columns you still want removed (besides source_module/source_reference_id):
  - [ ] All planned removals are reflected above
- Acceptable behavior for posted journals source fields in v_gl2_journals_single_line_posted:
  - [ ] Derive from lines
  - [ ] NULL out and rely on line-level source in GL datasets
- Export views:
  - [ ] Transactions-level export (arrays flattened) is sufficient
  - [ ] Need posted-only variants
  - [ ] Need line-level export flatten (one line per row) as a separate view
- Scheduling:
  - [ ] Desired refresh cadence (15m, hourly, nightly) and whether CONCURRENTLY is required everywhere

On approval, we will:
1) Rewrite legacy_compat.v_journals_single_line (or its posted wrapper) to remove header source field dependencies
2) Drop transactions.source_module and transactions.source_reference_id
3) Add posted-only export wrappers (if requested), finalize pg_cron schedules, and provide a consolidated, idempotent migration.sql to roll these changes through staging/prod with stop-and-verify comments.
